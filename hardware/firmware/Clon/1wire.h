#define 		__1_WIRE_DRIVER_				1			//макробъявление названия библиотеки (поможет скомпилировать :))
//-----------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------[управляющий вывод для опроса 1-wire  устройства]---
//-----------------------------------------------------------------------------------------------------------------------
  #define DeviceQ_IO		PIND
  #define DeviceQ_DDR		DDRD,		2			//Бит для записи
  #define DeviceQ_PIN		PIND,		2			//Бит для чтения
  #define DeviceQ_PORT	PORTD,	2			//Бит порта

//----------------------------------------------------------------------------------------------------------------------- 
//-----------------------------------------------------------------------------[команды на работу с 1 wire протоколом]---  
  #define READ_ROM									0x33		//команда позволяет прочитать содержимое ПЗУ. В ответ на эту команду DS18S20 передает 8-битный код семейства (10h), затем 48-битный серийный номер, а затем 8-битную CRC для проверки правильности принятой информации
  #define MATCH_ROM									0x55		//команда позволяет адресовать на шине конкретный термометр. После этой команды мастер должен передать нужный 64-битный код, и только тот термометр, который имеет такой код, будет «откликаться» до следующего импульса сброса
  #define SKIP_ROM									0xCC		//команда позволяет пропустить процедуру сравнения серийного номера и тем самым сэкономить время в системах, где на шине имеется всего одно устройство
  #define SEARCH_ROM								0xF0		//команда позволяет определить серийные номера всех термометров, присутствующих на шине
//----------------------------------------------------------------------------------------------------------------------- 
//---------------------------------------------------------------------------------------[команды на работу с DS2430A]--- 
  #define READ_APP_REG							0xC3
  #define COPY_LOCK_APP_REG					0x5A
  #define WRITE_APP_REG							0x99

  #define READ_STATUS_REG						0x66

  #define READ_SCRATCHPAD						0xAA		//Чтение блокнотной памяти
  #define READ_MEMORY								0xF0		//Чтение памяти
  #define WRITE_SCRATCHPAD					0x0F		//Запись блокнотной памяти
  #define COPY_SCRATCHPAD						0x55		//Копирование блокнота. Эта операция требует около 10мс
//----------------------------------------------------------------------------------------------------------------------- 
//--------------------------------------------------[ошибки, возникающие при работе с устройством по 1 wire протоколу]--- 
  volatile unsigned char _1_WIRE_ERROR= 0x00;		
													// 0x00 - нет устройства на шине
  												// 0x01 - устройство на шине
  												// 0x02 - короткое замыкание на землю
													// 0x03 - нет устройства в базе
													// 0x04 - не сошлось CRC
													// 0x05 - ошибка данных устройства
													// 0x06 - ошибка при прогоне команды CONVERT_T
													// 0x07 - ошибка при прогоне команды READ_SCRATCHPAD
													// 0x08 - неизвестная ошибка ошибка
//----------------------------------------------------------------------------------------------------------------------- 
//--------------------------------------------------------------------[Рекомендованные задержки от Dallas AppNote 126]--- 
 #define DeviceQ_delay_A				15
 #define DeviceQ_delay_B				64
 #define DeviceQ_delay_C				60
 #define DeviceQ_delay_D				10
 #define DeviceQ_delay_E				9
 #define DeviceQ_delay_F				50
 #define DeviceQ_delay_G				0
 #define DeviceQ_delay_H				490
 #define DeviceQ_delay_I				70
 #define DeviceQ_delay_J				410
 #define DeviceQ_delay_P				110
//----------------------------------------------------------------------------------------------------------------------- 
//------------------------------------------------------------------[Необходимые переменные для работы с устройсвами ]--- 

	u08		_OwClient_rom[8];														//адрес устройства
	u08		_OwClient_StatusReg[1];
	u08		_OwClient_AppReg[8];
	u08		_OwClient_ScratchPad[32];

 	u08		_deviceQ_last_line					= 0;
																						// 1 - Ожидаем команду ПЗУ
																						// 2 - Ожидаем бит
																						// 3 - Ожидаем команду ОЗУ

//----------------------------------------------------------------------------------------------------------------------- 



void Ping(bool A){
  #define Ping_DDR		DDRD,		3			//Бит для записи
  #define Ping_PORT		PORTD,	3			//Бит порта
	if (A) {
 		ClrBit(Ping_PORT);	
		NOP;
	 	ClrBit(Ping_DDR);	
		NOP;
		}				// для зарядки аккумулятора устройства на порту}
 	else	{
		ClrBit(Ping_PORT);	
		NOP;
		SetBit(Ping_DDR);	
		NOP;
		}				// передача импульса RESET}
	}
//----



//-------------------------------------------------------------------[Включить поддтяжку порта для зарядки устройства]--- 
void OwClient_Pullup(bool A){
	if (A) {
 		ClrBit(DeviceQ_PORT);	
		NOP;
	 	ClrBit(DeviceQ_DDR);	
		NOP;
		}				// для зарядки аккумулятора устройства на порту}
 	else	{
		ClrBit(DeviceQ_PORT);	
		NOP;
		SetBit(DeviceQ_DDR);	
		NOP;
		}				// передача импульса RESET}
	}
//----------------------------------------------------------------------------------------------------------------------- 


//-------------------------------------------------------------[установка начального направления порта для устройства]--- 
void OwClient_Init(void){
	OwClient_Pullup(1);								// для зарядки аккумулятора устройства на порту
	}
//----------------------------------------------------------------------------------------------------------------------- 


//-------------------------------------------------------------------------------------------------[OwClient_read_bit]--- 
u08 OwClient_read_bit(void){
	u08 result = 0x00;
	while (GetBitH(DeviceQ_PIN)) {if (_deviceQ_Is_Reset==1) break;};
	_delay_us(DeviceQ_delay_A);																			// задержка 15us 
  if (GetBitH(DeviceQ_PIN))	result = 0x01; else result = 0x00;		// если на ножке логическая 1 результат 1 								
	_delay_us(DeviceQ_delay_F);																			// жду конец таймслота
	return (result);																								// возвращаем значение линии данных
	}
//----------------------------------------------------------------------------------------------------------------------- 

//------------------------------------------------------------------------------------------------[OwClient_read_byte]--- 
u08 OwClient_read_byte(void){
	u08 result = 0x00;
 	for(int i = 0; i < 8; i++) {																		// цикл чтения бит
		if (_deviceQ_Is_Reset==1) break;
		result |= OwClient_read_bit() << i;
 		};
	return (result);	
	}
//----------------------------------------------------------------------------------------------------------------------- 
//--------------------------------------------------------------------------------------------------[OwClient_write_1]--- 
void OwClient_write_1(void){
	_delay_us(DeviceQ_delay_E);
	OwClient_Pullup(1);
	_delay_us(27);
}
//----------------------------------------------------------------------------------------------------------------------- 
//--------------------------------------------------------------------------------------------------[OwClient_write_0]--- 
void OwClient_write_0(void){
 	OwClient_Pullup(0);
	_delay_us(27);
	OwClient_Pullup(1);
}

//----------------------------------------------------------------------------------------------------------------------- 
//------------------------------------------------------------------------------------------------[OwClient_write_bit]--- 
void OwClient_write_bit(u08 data){
	while (GetBitH(DeviceQ_PIN)) {if (_deviceQ_Is_Reset==1) break;};  
	if (data !=0)	OwClient_write_1();																	// выводим очередной бит начиная с младшего
  	else				OwClient_write_0();
	}
//----------------------------------------------------------------------------------------------------------------------- 
//-----------------------------------------------------------------------------------------------[OwClient_write_byte]--- 
void OwClient_write_byte(u08 data){
	char count = 8;																										// формируем счетчик бит
	do{																																// цикл вывода бит на шину
		if (_deviceQ_Is_Reset==1) break;
		OwClient_write_bit(data & 0x01);																// выводим очередной бит начиная с младшего
  	data >>= 1;																											// сдвигаем данные вправо и проверяем окончание цикла
 		} while(--count);
	}
//----------------------------------------------------------------------------------------------------------------------- 


//--------------------------------------------------------------------------------------------------[OwClient_Present]--- 
void OwClient_Present(void){
	_delay_us(DeviceQ_delay_F);
	OwClient_Pullup(0);
	_delay_us(DeviceQ_delay_P);
	OwClient_Pullup(1);
	}
//----------------------------------------------------------------------------------------------------------------------- 
//-----------------------------------------------------------------------------------------------------------[Rom CMD]--- 
//-------------------------------------------------------------------------------------------------[OwClient_read_Rom]--- 
void OwClient_read_Rom(void){
	for (u08 i = 0; i < 8; i++) OwClient_write_byte(_OwClient_rom[i]);
	}
//----------------------------------------------------------------------------------------------------------------------- 
//------------------------------------------------------------------------------------------------[OwClient_match_Rom]--- 
void OwClient_match_Rom(void){
	for (u08 i = 0; i < 8; i++)
		if (OwClient_read_byte() != _OwClient_rom[i]) {
			while (_deviceQ_Is_Reset !=1); 
			break;
			};
	}
//----------------------------------------------------------------------------------------------------------------------- 
//-----------------------------------------------------------------------------------------------[OwClient_search_Rom]--- 
void OwClient_search_Rom(void){
	for (u08 i = 0; i < 8; i++) {
		char count = 8;	
		char data	=	_OwClient_rom[i];
		if (_deviceQ_Is_Reset==1) break;
		do{
			if (_deviceQ_Is_Reset==1) break;
			OwClient_write_bit(data & 0x01);																// выводим очередной бит начиная с младшего
			OwClient_write_bit((data & 0x01) ^ 0x01);												// выводим очередной бит начиная с младшего 		
			if (OwClient_read_bit() != (data & 0x01)) while (_deviceQ_Is_Reset !=1); 
			data >>= 1;																											// сдвигаем данные вправо и проверяем окончание цикла
 			} while(--count);
		};
	}
//-----------------------------------------------------------------------------------------------------------------------   
//----------------------------------------------------------------------------------------------------------------------- 
//-----------------------------------------------------------------------------------------------------------[Ram CMD]---
//-----------------------------------------------------------------------------------------[OwClient_write_ScratchPad]--- 
void OwClient_write_ScratchPad(void){
	u08 adr = 0;
	adr = OwClient_read_byte();
	do {
		_OwClient_ScratchPad[adr]=OwClient_read_byte();		
		if (adr<31) adr++; else adr=0;
		} while (_deviceQ_Is_Reset !=1);
	}
//----------------------------------------------------------------------------------------------------------------------- 
//------------------------------------------------------------------------------------------[OwClient_read_ScratchPad]--- 
void OwClient_read_ScratchPad(void){
	u08 adr = 0;
	adr = OwClient_read_byte();
	do {
		OwClient_write_byte(	_OwClient_ScratchPad[adr]);		
		if (adr<31) adr++; else adr=0;
		} while (_deviceQ_Is_Reset !=1);
	}
//----------------------------------------------------------------------------------------------------------------------- 
//------------------------------------------------------------------------------------------[OwClient_copy_ScratchPad]--- 
void OwClient_copy_ScratchPad(void){
	if (OwClient_read_byte() == 0xA5) 
		eeprom_write_block(_OwClient_ScratchPad, ERam, 32);
	do {} while (_deviceQ_Is_Reset !=1);
	}
//----------------------------------------------------------------------------------------------------------------------- 
//---------------------------------------------------------------------------------------------[OwClient_write_AppReg]--- 
void OwClient_write_AppReg(void){
	u08 adr = 0;
	adr = OwClient_read_byte();
	do {
		_OwClient_AppReg[adr]=OwClient_read_byte();		
		if (adr<7) adr++; else adr=0;
		} while (_deviceQ_Is_Reset !=1);
	}
//----------------------------------------------------------------------------------------------------------------------- 
//-------------------------------------------------------------------------------------------[OwClient_read_StatusReg]--- 
void OwClient_read_StatusReg(void){
	if (OwClient_read_byte() == 0x00) 
		OwClient_write_byte(_OwClient_StatusReg[0]);
	while (_deviceQ_Is_Reset !=1) OwClient_write_byte(1);
	}
//----------------------------------------------------------------------------------------------------------------------- 
//----------------------------------------------------------------------------------------------[OwClient_read_AppReg]--- 
void OwClient_read_AppReg(void){
	u08 adr = 0;
	adr = OwClient_read_byte();
	do {
		OwClient_write_byte(_OwClient_AppReg[adr]);		
		if (adr<7) adr++; else adr=0;
		} while (_deviceQ_Is_Reset !=1);
	}
//----------------------------------------------------------------------------------------------------------------------- 
//----------------------------------------------------------------------------------------------[OwClient_lock_AppReg]--- 
void OwClient_lock_AppReg(void){
	if ((OwClient_read_byte() == 0xA5) && (_OwClient_StatusReg[0] != 0xFC)) { 
		_OwClient_StatusReg[0] = 0xFC;
		eeprom_write_block(_OwClient_StatusReg,EStatusReg,1);
		eeprom_write_block(_OwClient_AppReg, EAppReg, 8);
		};
	while (_deviceQ_Is_Reset !=1);
	}
//----------------------------------------------------------------------------------------------------------------------- 
//----------------------------------------------------------------------------------------------------------------------- 
//--------------------------------------------------------------------------------------------[OwClient_check_Ram_CMD]--- 
void OwClient_check_Ram_CMD(u08 cmd){
	switch(cmd) {
		case READ_ROM: OwClient_read_Rom(); break;
		case MATCH_ROM: OwClient_match_Rom(); break;
		case SEARCH_ROM: OwClient_search_Rom(); break;
		case SKIP_ROM: break;
		default: while (_deviceQ_Is_Reset !=1); break;
		}
	}
//-----------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------[OwClient_check_Rom_CMD]--- 
void OwClient_check_Rom_CMD(u08 cmd){
	switch(cmd) {
		case WRITE_SCRATCHPAD: OwClient_write_ScratchPad(); break;
		case READ_SCRATCHPAD: OwClient_read_ScratchPad(); break;
		case COPY_SCRATCHPAD: OwClient_copy_ScratchPad(); break;
		case READ_MEMORY: OwClient_read_ScratchPad(); break;
		case WRITE_APP_REG: OwClient_write_AppReg(); break;
		case READ_STATUS_REG: OwClient_read_StatusReg(); break;
		case READ_APP_REG: OwClient_read_AppReg(); break;
		case COPY_LOCK_APP_REG: OwClient_lock_AppReg(); break;
		default: while (_deviceQ_Is_Reset !=1); break;
		}
	}
//----------------------------------------------------------------------------------------------------------------------- 
